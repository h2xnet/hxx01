{"meta":{"title":"零一会","subtitle":"用代码改变世界","description":"人生就是一场旅行，过好每一天，才不辜负这一生","author":"星光","url":"https://blog.h2xtrip.com","root":"/"},"pages":[{"title":"分类","date":"2023-10-29T13:15:07.000Z","updated":"2023-10-31T09:49:02.000Z","comments":true,"path":"categorys/index.html","permalink":"https://blog.h2xtrip.com/categorys/index.html","excerpt":"","text":""},{"title":"文章","date":"2023-10-29T13:17:02.000Z","updated":"2023-10-31T09:49:02.000Z","comments":true,"path":"posts/index.html","permalink":"https://blog.h2xtrip.com/posts/index.html","excerpt":"","text":""},{"title":"关于我们","date":"2023-10-29T13:18:25.000Z","updated":"2023-10-31T09:49:02.000Z","comments":true,"path":"about/index.html","permalink":"https://blog.h2xtrip.com/about/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-10-29T13:33:03.000Z","updated":"2023-10-31T09:49:02.000Z","comments":true,"path":"tags/index.html","permalink":"https://blog.h2xtrip.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"如何优雅地让多个版本的nodejs共存","date":"2023-11-05T13:45:18.903Z","updated":"2023-10-31T09:49:02.000Z","comments":true,"path":"2023/11/05/如何优雅地让多个版本的nodejs共存/","link":"","permalink":"https://blog.h2xtrip.com/2023/11/05/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E8%AE%A9%E5%A4%9A%E4%B8%AA%E7%89%88%E6%9C%AC%E7%9A%84nodejs%E5%85%B1%E5%AD%98/","excerpt":"","text":"如何优雅地让多个版本的nodejs共存？1 author: 星光 weixi:xingguangzfs 我们都知道，近几年 nodejs 大流行，曾经有一段时间，甚至有 JavaScript 一统天下的趋势，当然现在这种趋势在下降，我认为导致这种结果最主要的原因是还是性能。 简单的讲，nodejs 是基于 chrome v8 引擎的 JavaScript 运行环境，有了它，Javascript 即可以开发前端程序，又可以开发后端程序，这就产生了一种局面，就是会 Javascript ，就可以一个人完成一个项目，这对于小公司来说，是一种巨大的恩惠。 在用 nodejs 开发项目的时候，通常不同的项目使用的 nodejs 版本是不一样的，而且通常如果版本跨度比较大的话，往往导致版本之间兼容性差，甚至不兼容的情况产生，那么如何优雅的在多个 nodejs 版本之间切换呢？这时就要用到下面要介绍的工具 nvm。 nvm 全称 node.js version management ， 是开源的 nodejs 版本管理工具，windows 版本的 nvm 可以在下面地址下载： https://github.com/coreybutler/nvm-windows/releases 如果下载不了，也可以找我要，微信：xingguangzfs （1）安装nvm 下载好 nvm 后，首先就是安装，我下载的是 exe 安装包，安装很简单，双击打开后，一直 “下一步” ，直到安装完成即可。 安装完后，在 windows 开始菜单中找到 “命令提示符”，最好以管理员方式打开，然后输入命令：nvm version 显示出 nvm 版本信息说明安装成功，如下图所示： 接着输入命令：nvm ls 查看已经安装的 nodejs 版本列表，如下图所示： 因为是新安装，所以没有任何版本。 （2）安装 nodejs 接下来安装 nodejs ，安装时必须指定版本号，比如安装8.12.0版本输入： nvm install 8.12.0 安装会先下载，再安装，需要一点时间，如下图所示： 此时再输入查询命令：nvm ls 显示如下图所示： （3）指定要使用的 nodejs 版本 通过输入：nvm ls 查看已经安装的 nodjs 版本列表， 然后输入：nvm use 8.12.0 指定当前使用的 nodejs 版本，如下图所示： 接着可以输入：node -v 查看当前使用的 nodejs 版本。 （4）总结 当需要管理多个 nodejs 版本时，可以使用 nvm 工具非常方便优雅的进行管理，管理过程大致分为三步： 第一步：安装 nvm，直接用 nvm-setup.exe 安装包; 第二步：用 nvm 安装指定的 nodejs 版本，命令：nvm install 8.12.0 第三步：用 nvm 指定当前使用的 nodejs 版本，命令：nvm use 8.12.0 （5）附录 常用 nvm 命令表： [1] 安装指定的 nodejs 版本：nvm install 8.12.0 [2] 查看已经安装的 nodejs 列表：nvm ls [3] 指定当前使用的 nodejs 版本：nvm use 8.12.0 [4] 查看当前使用的 nodejs 版本：node -v","categories":[],"tags":[]},{"title":"","slug":"TWAIN扫描仪协议学习","date":"2023-11-05T13:45:18.899Z","updated":"2023-10-31T09:49:02.000Z","comments":true,"path":"2023/11/05/TWAIN扫描仪协议学习/","link":"","permalink":"https://blog.h2xtrip.com/2023/11/05/TWAIN%E6%89%AB%E6%8F%8F%E4%BB%AA%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"TWAIN扫描仪协议学习author: 星光 weixi:xingguangzfs （一）TWAIN介绍TWAIN协议，是一个软件和数码相机、扫描仪等图像输入设备之间的通讯标准。简言之，通过TWAIN协议，软件只需要用一种方法，就可以获得所有支持该协议的图像设备中的图像，不管你是数码相机、扫描仪、还是其它的图像设备。 TWAIN协议创建的目的就是兼容从不同外设上获取静态图像。TWAIN协议为操作系统提供了软件支持，使得符合TWAIN协议的软件通过调用TWAIN协议接口就能从兼容TWAIN协议的外设上获取静态图像，而不必考虑外设的功能差别。 从硬件到软件，TWAIN被设计成四层结构：硬件、源、源管理器和软件。 硬件厂家是通过硬件驱动程序支持TWAIN协议。TWAIN的硬件层接口被称为源，源管理器负责管理来自不同硬件厂家的源。软件不直接调用硬件厂家的TWAIN接口，而是通过向源管理器发送命令方式间接操控硬件。 （二）TWAIN结构TWAIN依靠三个组件协同完成与图像设备间的通讯和数据传输，这三个组件就是：Application，Source Manager和Source。 （1）Application：就是你所要编写的应用程序。 （2）Source Manager：由TWAIN提供的源管理器，它会搜集本地安装的所有符合TWAIN标准的图像设备，并根据需要去加载。同时担任Application和Source之间的桥梁。实际上Application 对Source的所有操作都是由Source Manager代劳的。 （3）Source：指代图像设备，实际在系统中是指由设备供应商提供的支持TWAIN协议的DLL文件，Source Manager通过调用里面的方法与设备进行通讯和数据传输。 123在实际应用中，Application与Source Manager间的通讯是通过TWAIN提供的DSM_Entry()函数实现。而Source Manager而与Source之间的通讯是通过TWAIN提供的DS_Entry()函数实现。 （三）TWAIN接口函数要编写应用程序实现与支持TWAIN协议的图像设备通讯，只需要了解上面提到DSM_Entry()接口函数就够了。这个过程有点类似于HTTP的一问一答模式，通过DSM_Entry()向Source Manager发送一条命令，就可以控制图像设备，或者获取设备信息。内部Source Manager会帮忙处理好中间的过程，应用程序无需关心。 TWAIN定义了一百多个命令消息，Application只需要通过DSM_Entry()函数将命令消息发送给Source Manager，就可以控制图像设备。TWAIN把它定义的操作称为Triplets操作，每个操作用三个定义参数来表示，而这三个参数用不同的前缀来区分。每个Triplets操作都是唯一的，不会有歧意，它代表一个特定的操作行为。这三个前缀分别是： Data Group(前缀名DG)、Data Argument(前缀名DAT)、Message ID(前缀名MSG_)，每个参数都有各自包含的信息。比如：DG_CONTROL&#x2F;DAT_PARENT&#x2F;MSG_OPENDSM代表打开Source Manager管理器，而DG_CONTROL&#x2F;DAT_PARENT&#x2F;MSG_CLOSEDSM则表示关闭已经打开的Source Manager。更多的定义可以查询相关手册资料，或者见后面附录。 现在我们知道了DSM_Entry()函数，那么怎么得到它呢?就需要在你的应用程序中包含twain.h头文件，并且加载相应的库，这些库在不同的平台由不同的文件实现，比如windows下调用LoadLibrary加载twain_32.dll&#x2F;twain_64.dll库，并调用GetProcAddress获取DSM_Entry()函数的地址指针，之后就可以调用DSM_Entry向设备发送指令了。 现在我们已经明白TWAIN所有的操作都是通过DSM_Entry（）函数来实现的，我们先来持下它的定义： 123456DSMENTRY DSM_Entry(TW_IDENTITY *_pOrigin, // 指示发起者指针 TW_IDENTITY *_pDest, // 指示接收者指针 TW_UINT32 _DG, // Triplets操作DG参数 TW_UINT16 _DAT, // Triplets操作DAT参数 TW_UINT16 _MSG, // Triplets操作MSG参数 TW_MEMREF _pData)// 返回数据块的指针 函数执行成功，会返回TWRC_SUCCESS，失败会返回错误码，具体的可以参数手册或者后面的附录。 （四）TWAIN处理流程Application、Source Manager、Source之间要实现数据传输，必须遵循一定的流程，不同的操作需要放到合适的流程中去处理。为此，TWAIN规定了S1到S7共7种状态来管理不同的流程，这7种状态分为两类，S1到S3为Source Manager所有，而S4到S7为Source所有，各状态如下所示： 状态1：准备会话，此时Application与Source Manager还没有建立连接，此时标志位为1； 状态2：加载Source Manager，此时已经成功加载到内存中，但是还没有打开，已经做好了接受Triplets操作请求的准备，此时标志位为2； 状态3：打开Source Manager，此时已经成功打开，做好了管理source的准备，此时标志位为3； 备注：一个Application只能打开一个Source Manager，而一个Source Manager可以管理多个Source，并且多个Source之间互相独立，互不干扰。 状态4：打开Source，此时可以查询或设置Source的属性，比如分辨率，是否支持彩色等，此时标志位为4； 状态5：Source可用，此时Source已经打开成功，并初始化完成，可以正常工作了。此时可以发一个T riplets操作，选择是否让Source显示它自身的操作界面，此时标志位为5； 状态6：准备数据传输，此时Source已经准备好为Application传输数据，如果有音频数据要传输，则Application必须确保在传输图像数据之前，先把音频数据传输完成，此时标志位为6； 状态7：数据传输开始，Source开始数据传输，此时标志位为7； 下面我将依照操作流程简要介绍状态转移过程： （1）程序刚启动时，默认状态是S1； （2）初始化库，获取到DSM_Entry()函数指针后，状态会从S1转到S2； （3）打开Source Manager成功后，状态从S2转到S3； ​ Triplets操作：DG_CONTROL&#x2F;DAT_PARENT&#x2F;MSG_OPENDSM ​ S3状态下可以执行的主要操作有： ​ DG_CONTROL&#x2F;DAT_IDENTITY&#x2F;MSG_USERSELECT ： 显示系统默认的设备选择列表； ​ DG_CONTROL&#x2F;DAT_IDENTITY&#x2F;MSG_GETDEFAULT ：获取默认图像设备； ​ DG_CONTROL&#x2F;DAT_IDENTITY&#x2F;MSG_GETFIRST ：遍历图像列表时使用，获取列表第一个设备； ​ DG_CONTROL&#x2F;DAT_IDENTITY&#x2F;MSG_GETNEXT ： 遍历图像列表时使用，获取列表下一个设备； ​ 返回操作 : 执行DG_CONTROL&#x2F;DAT_PARENT&#x2F;MSG_CLOSEDSM操作，则状态会从S3转到S2； ​ （4）打开某个Source后，状态从S3转到S4，S4状态下可以设置或获取源的各种性能参数； ​ Triplets操作：DG_CONTROL&#x2F;DAT_IDENTITY&#x2F;MSG_OPENDS ​ S4状态下可执行的主要操作： ​ DG_CONTROL&#x2F;DAT_CAPABILITY&#x2F;MSG_GET : 获取源的属性 ​ DG_CONTROL&#x2F;DAT_CAPABILITY&#x2F;MSG_SET : 设置源的属性 ​ 通过上述两个操作，可以查询设备的信息，或者定制设备的功能。 （5）请求从Source获取数据，状态从S4转到S5，比如对于扫描仪，就是请求扫描； ​ Triplets操作：DG_CONTROL&#x2F;DAT_USERINTERFACE&#x2F;MSG_ENABLEDS （6）当准备传输数据时，状态从S5转到S6； ​ Triplets操作：DG_CONTROL&#x2F;DAT_EVENT&#x2F;MSG_PROCESSEVENT ​ 备注：MSG_PROCESSEVENT是由Source发送的，而不是Application发送，Source Manager需要 监听MSG_PROCESSEVENT事件，并且当为MSG_XFERREADY时表示数据已经准备好，状态就从S5 转到S6； （7）开始进行数据传输，状态从S6转到S7； ​ Triplets操作：DG_IMAGE&#x2F;DAT_IMAGEINFO&#x2F;MSG_GET或 ​ DG_IMAGE&#x2F;DAT_IMAGENATIVEXFER&#x2F;MSG_GET等 （8）终止数据传输，状态从S7转到S6，再转到S5； ​ Triplets操作：DG_CONTROL&#x2F;DAT_PENDINGXFERS&#x2F;MSG_ENDXFER （9）断开会话，即取消某个会话，状态从S5转到S4； ​ Triplets操作：DG_CONTROL&#x2F;DAT_USERINTERFACE&#x2F;MSG_DISABLEDS （10）关闭会话，即关闭某个Source，状态从S4转到S3； ​ Triplets操作：DG_CONTROL&#x2F;DAT_USERINTERFACE&#x2F;MSG_CLOSEDS （11）关闭Source Manager，状态从S3转到S2； ​ Triplets操作：DG_CONTROL&#x2F;DAT_PARENT&#x2F;MSG_CLOSEDSM （五）TWAIN数据传输模式TWAIN协议定义了三种数据传输模式，用于把数据从Source传输到Application。分别是本地模式、文件模式和缓存模式。下面对每一种模式做简单介绍： 备注：对于音频数据，只能选择本地模式或文件模式进行传输。 （1）本地模式： 所有图像设备都支持本地模式，并且是TWAIN默认的传输模式，它是最容易实现的数据传输模式，但它有一定局限性，只支持DIB图像数据，并且传输时会受到内存大小的限制。 实现原理：Source在传输数据时，会单独分配一块内存，把数据存储在此内存中，然后把内存地址告诉Application，Application收到通知后，从内存中获取图像数据，并且要负责释放内在。此模式下，如果当前系统可用内存小于图像大小，则会导致传输失败。 （2）文件模式 该模式是让Application创建一个文件，这个文件用于存储传输的数据，Source将对此文件进行读写操作。Source把要传输的数据写入此文件中，Application通过访问该文件，就可获取传输的数据。 当使用本地模式传输一个大的图像数据，内在不够大时，可以使用该模式来传输。文件模式与缓存模式相比，操作简单，但是传输速度要慢，并且传输完成后，Application还需要去管理此文件。 （3）缓存模式 缓存模式在整个传输过程中，使用一个或多个内在缓存区，内存的分配和释放由Application控制。传输过程中，数据被当成一个字节流进行处理，Application必须使用TW_IMAGEINFO 和 TW_IMAGEMEMXFER操作，去获取各个缓存区的信息并把它们正确组织为一个完整的位图。 如果使用本地模式或者文件模式去处理，则整个传输过程只需要一个Triplets操作就可以完成，但缓存模式，必须要发送多个Triplets操作，不断去获取缓存冲数据，直到获取完成为止。但是，该模式具有很好的灵活性，可以更好的控制数据的获取方式，只是编程上会麻烦一些。 （六）TWAIN应用实践经过以上的学习，相信大家对TWAIN协议有了一定的了解，学习的目的是为了应用，接下来最重要的就是应用以上学习的知识，来实现一个自己的扫描仪控制应用程序。很庆幸的是在github上找到了一个非常不错的开源项目，利用这个项目，可以很方便、很快速的实现自己的扫描工具。 TWAIN下载地址：https://github.com/twain （1）首先，下载twain-dsm 下载地址：twain-dsm twain-dsm ： 此项目由C++开发，支持Windows&#x2F;Linux&#x2F;MacOS，实现了对Source Manager操作功能的封装。本人在Windows下用VS2017编译，进入twain-dsm&#x2F;TWAIN_DSM&#x2F;visual_studio&#x2F;目录，打开对应的版本，把下面的代码注释掉，在属性中选择对应的Windows SDK版本，就可以编译了。 12345CTwnDsmLog::Log()&#123;​ // assert(0); // 注释掉此行，作用是当发生错误时弹出崩溃窗口&#125; （2）其次，下载对应的Application版本 比如C#程序选择twain-cs C++程序选择twain-samples C程序选择twain-specification 等等。 我选择的C#版本，用VS2017编译后，记得把之前编译好的TWAINDSM.dll文件复制到twain-cs&#x2F;bin&#x2F;debug目录下，与exe文件同一目录，之后就可以运行了。 备注：如果你使用的是C#版本，你要把代码集成到你自己的程序里面，记得TWAIN对象必须建立在Form对话框之下，因此TWAIN内部使用了对话框的事件循环，否则将会遇到程序卡死的情况。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2023-11-05T13:45:18.897Z","updated":"2023-10-31T09:49:02.000Z","comments":true,"path":"2023/11/05/hello-world/","link":"","permalink":"https://blog.h2xtrip.com/2023/11/05/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"C++高级特性系列（1）","slug":"cpp-adv-1","date":"2021-06-13T09:25:00.000Z","updated":"2023-10-31T09:49:02.000Z","comments":true,"path":"2021/06/13/cpp-adv-1/","link":"","permalink":"https://blog.h2xtrip.com/2021/06/13/cpp-adv-1/","excerpt":"","text":"C++新特性系列之向后兼容（一）兼容C99C11之前最新的C标准是1999年制定的C99标准。而第一个C++语言标准却出现在1998年（常被称为C98），之后推出的C++标准也只是进行小的修正，直到出现C++11标准。它们主要有： （1）预定义宏 _STDC_HOSTED_ ：如果编译器的目标系统环境中包含完整的标准C库，则此宏值为1，否则为0； _STDC_ ：C编译器通过这个宏来表示编译器的实现是否与C标准一致； _STDC_VERSION_ ：C编译器通过此宏来表示支持的C标准版本； _STDC_ISO_10646_ ：这个宏定义为一个yyyymmL格式的整数常量，例如199712L，用来表示C++编译环境符合某个版本的ISO&#x2F;IEC 10646标准； 通过上面的这些宏，可以验证机器环境对C和C++库的支持状况。 （2）__func__预定义标识符 功能：返回所在函数的名字；在轻量调试的时候特别有用，可以快速定位到问题函数； 注意：不允许作为函数的默认返回值；原因是因为在参数声明时，__func__还未被定义； (3) _Pragma操作 C&#x2F;C++标准中，#pragma是一条预处理指令，用它向编译器发送指令进行预处理； 比如#pragma once用于告诉编译器，这个文件只加载一次，功能与以下指令等效： #ifndef #define #endif 再比如下面语句用于静态加载库链接文件: #pragma comment(lib, &quot;user32.lib&quot;) 而在C++高级特性中，提供了_Pragma操作符来实现上述功能，格式：__Pragma(“once”)，参数是一个字符串，可以在宏中使用，因此会有更大的灵活性。 （4）变长参数的宏定义，以及___VA_ARGS__ 在C99标准中，用三个”…”来代表变长参数，取参数需要用 va_start &#x2F; va_end &#x2F; va_list &#x2F; va_arg 组合来取参数，比如下面的代码： void Printf(const char* format, ...) &#123; va_list ap; va_start(ap, format); vprintf(format, ap); va_end(ap); &#125; 在使用高级特性的情况下，上述函数就可简化为： 1#define Printf(format, ...) printf(format, __VA_ARGS__) （5）宽字符连接 在C++11新标准之前，将榨字符（char）转为宽字符（wchar_t）是未定义的，但在新标准了，明确了在char和wchar_t进行连接时，会自动将char转为wchar_t再进行连接。 （二）long long整long long整型在1995年就有人提议写进C98标准，但被C++委员会拒绝，后来被写进C99标准，同时也被很多编译器支持，于是在C++11中正式被加入到标准中。 long long整型有两种类型：long long和无符号unsigned long long C++11标准要求，long long整型在不同的平台上有不同的长度，但至少要有64位长度。我们在写常数时可以在末尾加LL（或ll）表明是long long整型。 比如： ​ long long val1 = -9289398LL; ​ unsigned long long uval2 = 9283938ULL; 同时，在C++11中，有很多与long long等价的类型，比如long long， signed long long，long long int，signed long long int都是等价的,无符号数也一样。 要了解平台上的long long大小，可以查看或&lt;limits.h&gt;进行查看，比如：","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://blog.h2xtrip.com/tags/C/"}]},{"title":"爱恨C++","slug":"爱恨CPP","date":"2021-03-21T08:58:31.000Z","updated":"2023-10-31T09:49:02.000Z","comments":true,"path":"2021/03/21/爱恨CPP/","link":"","permalink":"https://blog.h2xtrip.com/2021/03/21/%E7%88%B1%E6%81%A8CPP/","excerpt":"","text":"C++，一门古老而强大的编程语言。","categories":[{"name":"编程","slug":"编程","permalink":"https://blog.h2xtrip.com/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://blog.h2xtrip.com/tags/C-C/"}]}],"categories":[{"name":"编程","slug":"编程","permalink":"https://blog.h2xtrip.com/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://blog.h2xtrip.com/tags/C/"},{"name":"C/C++","slug":"C-C","permalink":"https://blog.h2xtrip.com/tags/C-C/"}]}